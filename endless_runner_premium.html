<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Endless Runner — Premium (Extended)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    #game-container{width:100%;height:100vh;display:flex;align-items:center;justify-content:center}
    .ui{position:fixed;z-index:999;left:12px;top:12px}
    .hud{position:fixed;right:12px;top:12px;z-index:999;text-align:right}
    .controls{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);z-index:999;display:flex;gap:8px}
    .button{background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.06);backdrop-filter:blur(6px);padding:8px 12px;border-radius:12px;color:#fff;cursor:pointer}
    .panel{background:rgba(10,12,16,0.55);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);margin-bottom:8px;min-width:220px}
    .small{font-size:12px;color:#ddd}
    .muted{opacity:0.6}
    input[type=range]{width:120px}
    .shop-item{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px}
    .shop-item button{margin-left:auto}
    .center-col{display:flex;flex-direction:column;gap:6px}
  </style>
</head>
<body>
  <div id="game-container"></div>

  <div class="ui">
    <div class="panel">
      <div class="small">Endless Runner — Premium Extended</div>
      <div class="small">Controls: ← → lanes • ↑ jump • ↓ slide • C switch char • T theme • P pause</div>
    </div>

    <div class="panel">
      <div class="small">Audio: upload music/SFX to override procedural audio</div>
      <input id="musicFile" type="file" accept="audio/*"><br>
      <input id="sfxFile" type="file" accept="audio/*"><br>
      <div class="small">Music vol <input id="musicVol" type="range" min="0" max="1" step="0.01" value="0.6"></div>
      <div class="small">SFX vol <input id="sfxVol" type="range" min="0" max="1" step="0.01" value="0.9"></div>
      <div style="height:6px"></div>
      <button id="exportZip" class="button">Export ZIP (playable)</button>
    </div>

    <div class="panel" id="shopPanel">
      <div class="small">Coins: <span id="coinCount">0</span></div>
      <div class="small">Shop</div>
      <div id="shopList"></div>
      <div style="height:6px"></div>
      <button id="resetSave" class="button small">Reset Save</button>
    </div>
  </div>

  <div class="hud">
    <div class="panel small">Score: <span id="score">0</span></div>
    <div class="panel small">Theme: <span id="themeName">Summer Rail</span></div>
    <div class="panel small">Leaderboards</div>
    <div class="panel" id="leaderboard"></div>
  </div>

  <div class="controls">
    <button id="btnChar" class="button">Switch Character</button>
    <button id="btnTheme" class="button">Change Theme</button>
    <button id="btnMute" class="button">Mute</button>
  </div>

  <!-- Phaser 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <!-- JSZip for export -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>
  <!-- FileSaver to save zip -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
  // Premium extended single-file game
  // Features added: animated characters (run/jump/slide), custom audio uploads, volume controls,
  // lighting/bloom-like glow, shop + coins, missions & levels, leaderboard (localStorage), save state, export ZIP.

  // ---------------- CONFIG & BOOT ----------------
  const CONFIG = {WIDTH: Math.min(window.innerWidth, 1024), HEIGHT: Math.min(window.innerHeight, 720)};

  const gameConfig = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: CONFIG.WIDTH,
    height: CONFIG.HEIGHT,
    backgroundColor: '#07101a',
    scale: {mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH},
    physics: {default: 'arcade', arcade: {gravity: {y: 1400}, debug: false}},
    scene: [BootScene, MainScene, UIScene]
  };

  const game = new Phaser.Game(gameConfig);

  // ---------------- UTIL: Save Manager ----------------
  const Save = {
    key: 'premium_runner_save_v1',
    defaultData(){ return {coins:0, unlockedChars:[0], bestScores:[], purchased:{}} },
    load(){try{const raw=localStorage.getItem(this.key); return raw?JSON.parse(raw):this.defaultData();}catch(e){return this.defaultData();}},
    save(data){localStorage.setItem(this.key, JSON.stringify(data));},
    reset(){localStorage.removeItem(this.key);}
  };

  // ---------------- SCENE: Boot ----------------
  function BootScene(){ Phaser.Scene.call(this,{key:'BootScene'}); }
  BootScene.prototype = Object.create(Phaser.Scene.prototype);
  BootScene.prototype.constructor = BootScene;
  BootScene.prototype.preload = function(){
    // generate animated sprite sheets procedurally for 4 characters (3 new + base)
    this.generateCharSheets();
    // primitives
    this.textures.createCanvas('rail', 800, 64).context.fillStyle='#333'; this.textures.get('rail').draw(0,0);
  };
  BootScene.prototype.create = function(){ this.scene.start('MainScene'); };

  BootScene.prototype.generateCharSheets = function(){
    // We'll create spritesheets with 6 frames (run), 2 frames jump, 2 frames slide per char stored in atlas-like keys
    const chars = [
      {id:0,name:'Neon Runner', palette:['#08f','#0ff','#7af'] , cost:0},
      {id:1,name:'Chrome Rider', palette:['#e6f','#a0f','#fff'] , cost:500},
      {id:2,name:'Dust Nomad', palette:['#ffb86b','#ff7e5f','#6b382a'], cost:600},
      {id:3,name:'Ember Scout', palette:['#ff6b6b','#ffca6b','#2b1b0b'], cost:800}
    ];
    this.registry.set('charDefs', chars);

    chars.forEach((c)=>{
      const sheetW = 192, sheetH = 96; // 6 frames across
      const canvasKey = 'charSheet' + c.id;
      const rt = this.textures.createCanvas(canvasKey, sheetW, sheetH);
      const ctx = rt.getContext();
      // draw 6 run frames as simple stylized rectangles with small shifts to simulate animation
      for(let f=0; f<6; f++){
        const fx = f*32;
        // body gradient
        const g = ctx.createLinearGradient(fx,0,fx+32,96);
        g.addColorStop(0,c.palette[0]); g.addColorStop(1,c.palette[1]); ctx.fillStyle = g; ctx.fillRect(fx+4,8,24,72);
        // helmet
        ctx.fillStyle = c.palette[2]; ctx.fillRect(fx+8,8,16,12);
        // eye
        ctx.fillStyle = '#000'; ctx.fillRect(fx+12,24,4,4);
        // legs simple stroke to suggest motion
        ctx.strokeStyle = '#111'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(fx+8,70); ctx.lineTo(fx+8+ (f%2?6:-6),86); ctx.moveTo(fx+24,70); ctx.lineTo(fx+24+ (f%3? -6:6),86); ctx.stroke();
      }
      // jump frames (2) placed after run frames
      for(let f=0; f<2; f++){
        const fx = (6+f)*32;
        ctx.fillStyle = c.palette[1]; ctx.fillRect(fx+4,6,24,78);
        ctx.fillStyle = c.palette[2]; ctx.fillRect(fx+8,6,16,12);
      }
      // slide frames (2)
      for(let f=0; f<2; f++){
        const fx = (8+f)*32;
        ctx.fillStyle = c.palette[0]; ctx.fillRect(fx+4,36,28,36);
        ctx.fillStyle = c.palette[2]; ctx.fillRect(fx+6,36,20,8);
      }
      rt.refresh();
    });
  };

  // ---------------- SCENE: Main (game) ----------------
  function MainScene(){ Phaser.Scene.call(this,{key:'MainScene'}); }
  MainScene.prototype = Object.create(Phaser.Scene.prototype);
  MainScene.prototype.constructor = MainScene;

  MainScene.prototype.init = function(){
    this.lanes = [CONFIG.HEIGHT*0.45, CONFIG.HEIGHT*0.6, CONFIG.HEIGHT*0.78];
    this.currentLane = 1;
    this.speed = 480; this.score=0; this.coins=0;
    this.charIndex=0; this.themeIndex=0;
    this.spawnTimer = 0; this.obstacleDelay = 800;
    this.gameLevel = 1; this.missions = [{desc:'Collect 5 coins', goal:5, progress:0, reward:100}];
    this.save = Save.load(); this.coins = this.save.coins || 0; this.unlockedChars = new Set(this.save.unlockedChars || [0]);
  };

  MainScene.prototype.create = function(){
    // background with glow layers to fake bloom/lighting
    this.bg = this.add.rectangle(0,0,CONFIG.WIDTH*2,CONFIG.HEIGHT*2,0x07101a).setOrigin(0);
    this.glow = this.add.graphics();
    this.bgShapes = this.add.container();

    // rail tile
    this.rail = this.add.tileSprite(0,this.lanes[1]+50, CONFIG.WIDTH*2, 80, 'rail').setOrigin(0,0);

    // groups
    this.obstacles = this.physics.add.group(); this.coinsGroup = this.physics.add.group(); this.powerups = this.physics.add.group();

    // player sprite using spritesheet texture from Boot
    const charDefs = this.registry.get('charDefs');
    this.charDefs = charDefs;

    // create an animation atlas per character
    charDefs.forEach(c=>{
      const key = 'charAnim' + c.id; if(this.anims.exists(key)) return;
      // run frames 0-5
      this.anims.create({key:key+'_run', frames: this.anims.generateFrameNumbers('charSheet'+c.id, {start:0,end:5, first:0, frames:undefined}), frameRate:12, repeat:-1});
      this.anims.create({key:key+'_jump', frames: this.anims.generateFrameNumbers('charSheet'+c.id, {start:6,end:7}), frameRate:8, repeat:0});
      this.anims.create({key:key+'_slide', frames: this.anims.generateFrameNumbers('charSheet'+c.id, {start:8,end:9}), frameRate:8, repeat:0});
    });

    // default player
    this.player = this.physics.add.sprite(160, this.lanes[this.currentLane], 'charSheet0').setScale(1.2).setDepth(10);
    this.player.body.setSize(36,86).setOffset(10,6);
    this.playCharAnim();

    // collisions
    this.physics.add.overlap(this.player, this.coinsGroup, this.collectCoin, null, this);
    this.physics.add.collider(this.player, this.obstacles, this.onHit, null, this);

    // input
    this.cursors = this.input.keyboard.createCursorKeys();
    this.input.keyboard.on('keydown-C', ()=>this.switchCharacter());
    this.input.keyboard.on('keydown-T', ()=>this.switchTheme());
    this.input.keyboard.on('keydown-P', ()=>this.togglePause());

    // create UI Scene overlay
    this.scene.launch('UIScene');

    // create simple lighting: an invisible light source following player
    this.playerLight = this.add.circle(this.player.x+40, this.player.y-30, 120, 0xffffff, 0.06).setBlendMode(Phaser.BlendModes.ADD).setDepth(5);

    // music manager (allows external file usage)
    this.setupAudio();

    // timers
    this.time.addEvent({delay:1000, callback:()=>this.maybeRollMissions(), loop:true});

    // initial theme
    this.applyTheme();

    // load shop UI
    this.events.on('coinsChanged', ()=>{ this.save.coins=this.coins; Save.save(this.save); document.getElementById('coinCount').innerText=this.coins; });
    document.getElementById('coinCount').innerText=this.coins;

    // start spawn loop using update
  };

  MainScene.prototype.update = function(time, dt){
    if(this.sys.isPaused) return;
    // input
    if(Phaser.Input.Keyboard.JustDown(this.cursors.left)) this.changeLane(-1);
    if(Phaser.Input.Keyboard.JustDown(this.cursors.right)) this.changeLane(1);
    if(Phaser.Input.Keyboard.JustDown(this.cursors.up)) this.jump();
    if(Phaser.Input.Keyboard.JustDown(this.cursors.down)) this.slide();

    // player easing to lane
    const targetY = this.lanes[this.currentLane];
    this.player.y = Phaser.Math.Linear(this.player.y, targetY, 0.18);
    this.playerLight.x = this.player.x+40; this.playerLight.y = this.player.y-30;

    // animate rail and bg for parallax
    this.rail.tilePositionX += this.speed * dt/1000;

    // move obstacles & coins
    this.obstacles.children.iterate(o=>{ if(!o) return; o.x -= this.speed * dt/1000; if(o.x < -100) o.destroy(); });
    this.coinsGroup.children.iterate(c=>{ if(!c) return; c.x -= this.speed * dt/1000; if(c.x < -50) c.destroy(); });

    // spawn
    this.spawnTimer += dt;
    if(this.spawnTimer > this.obstacleDelay){ this.spawnTimer = 0; this.spawnObstacle(); if(Math.random()<0.6) this.spawnCoin(); }

    // score increases
    this.score += (this.speed/1000)*dt*0.1; document.getElementById('score').innerText = Math.floor(this.score);

    // missions check
    // update UI
  };

  MainScene.prototype.changeLane = function(dir){ this.currentLane = Phaser.Math.Clamp(this.currentLane+dir,0,2); this.scene.get('UIScene').shakeUI(); };
  MainScene.prototype.jump = function(){ if(this.player.body.velocity.y===0){ this.player.body.setVelocityY(-600); this.playSfx(720,0.12); this.player.play('charAnim'+this.charIndex+'_jump'); this.time.delayedCall(400, ()=>this.playCharAnim()); } };
  MainScene.prototype.slide = function(){ const savedH=this.player.body.height; this.player.body.setSize(48,46).setOffset(6,40); this.player.play('charAnim'+this.charIndex+'_slide'); this.playSfx(380,0.08); this.time.delayedCall(500, ()=>{ this.player.body.setSize(36,86).setOffset(10,6); this.playCharAnim(); }); };

  MainScene.prototype.spawnObstacle = function(){ const lane = Phaser.Math.Between(0,2); const x=CONFIG.WIDTH+120; const ob = this.obstacles.create(x, this.lanes[lane], null).setImmovable(true); const g = this.add.graphics(); g.fillStyle(0x6b3f2a,1); g.fillRect(0,0,48,64); const texKey='ob'+Date.now()+Math.random(); g.generateTexture(texKey,48,64); g.destroy(); ob.setTexture(texKey).setOrigin(0.5,1); ob.body.allowGravity=false; };
  MainScene.prototype.spawnCoin = function(){ const lane = Phaser.Math.Between(0,2); const x=CONFIG.WIDTH+60; const c = this.coinsGroup.create(x, this.lanes[lane]-30,'').setDepth(9); const g=this.add.graphics(); g.fillStyle(0xffd166,1); g.fillCircle(12,12,12); const k='coin'+Date.now()+Math.random(); g.generateTexture(k,24,24); g.destroy(); c.setTexture(k); c.body.allowGravity=false; };

  MainScene.prototype.collectCoin = function(player, coin){ coin.destroy(); this.coins += 10; this.save.coins=this.coins; Save.save(this.save); this.events.emit('coinsChanged'); this.playSfx(1200,0.12); // mission progress
    if(this.missions.length){ this.missions[0].progress++; if(this.missions[0].progress>=this.missions[0].goal){ this.coins += this.missions[0].reward; this.missions.shift(); this.events.emit('coinsChanged'); }} };

  MainScene.prototype.onHit = function(player, ob){ ob.destroy(); this.cameras.main.shake(220,0.02); this.playSfx(160,0.24); this.score = Math.max(0,this.score-200); };

  MainScene.prototype.switchCharacter = function(){ // cycle through unlocked characters only
    const defs = this.charDefs; const unlocked = Array.from(this.unlockedChars); const idx = unlocked.indexOf(this.charIndex); const next = unlocked[(idx+1)%unlocked.length]; this.charIndex = next; this.playCharAnim(); this.playSfx(880,0.06); };

  MainScene.prototype.playCharAnim = function(){ this.player.play('charAnim'+this.charIndex+'_run'); };

  MainScene.prototype.switchTheme = function(){ this.themeIndex = (this.themeIndex+1)%3; document.getElementById('themeName').innerText=this.themeIndex===0?'Summer Rail':this.themeIndex===1?'Winter Rail':'Desert Rail'; this.applyTheme(); this.playSfx(420,0.07); };

  MainScene.prototype.applyTheme = function(){ const t=this.themeIndex; this.glow.clear(); this.bgShapes.removeAll(true);
    if(t===0){ this.cameras.main.setBackgroundColor('#87CEEB'); this.glow.fillStyle(0xFFD27A,0.06); this.glow.fillCircle(720,80,120); }
    else if(t===1){ this.cameras.main.setBackgroundColor('#cfe9ff'); this.glow.fillStyle(0xffffff,0.06); this.glow.fillRect(0,480,1200,240); }
    else { this.cameras.main.setBackgroundColor('#FFD59A'); this.glow.fillStyle(0xDFA96B,0.06); this.glow.fillEllipse(420,460,540,240); }
  };

  // ---------------- AUDIO: allow external uploads and volume control ----------------
  MainScene.prototype.setupAudio = function(){
    const AudioCtx = window.AudioContext || window.webkitAudioContext; this.audioCtx = new AudioCtx(); this.master = this.audioCtx.createGain(); this.master.gain.value=1; this.master.connect(this.audioCtx.destination);
    this.musicGain = this.audioCtx.createGain(); this.musicGain.gain.value = parseFloat(document.getElementById('musicVol').value); this.musicGain.connect(this.master);
    this.sfxGain = this.audioCtx.createGain(); this.sfxGain.gain.value = parseFloat(document.getElementById('sfxVol').value); this.sfxGain.connect(this.master);

    document.getElementById('musicVol').oninput = (e)=>{ this.musicGain.gain.value = parseFloat(e.target.value); };
    document.getElementById('sfxVol').oninput = (e)=>{ this.sfxGain.gain.value = parseFloat(e.target.value); };

    // procedural background loop fallback
    this.startBgLoop();

    // file inputs
    document.getElementById('musicFile').onchange = (ev)=>{ this.loadExternalAudio(ev.target.files[0], 'music'); };
    document.getElementById('sfxFile').onchange = (ev)=>{ this.loadExternalAudio(ev.target.files[0], 'sfx'); };
  };

  MainScene.prototype.loadExternalAudio = function(file, kind){ if(!file) return; const reader = new FileReader(); reader.onload = (e)=>{ this.audioCtx.decodeAudioData(e.target.result, (buffer)=>{ if(kind==='music'){ if(this.bgSource) this.bgSource.stop(); this.bgSource = this.audioCtx.createBufferSource(); this.bgSource.buffer = buffer; this.bgSource.loop = true; this.bgSource.connect(this.musicGain); this.bgSource.start(); } else { this.customSfx = buffer; } }, ()=>console.warn('decode error')); }; reader.readAsArrayBuffer(file); };

  MainScene.prototype.startBgLoop = function(){ // simple arpeggio generator as fallback
    if(this.bgOscInterval) clearInterval(this.bgOscInterval);
    const ctx=this.audioCtx; const notes=[220,261.63,329.63,392]; let i=0; this.bgOscInterval=setInterval(()=>{ const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.value = notes[i%notes.length]; o.connect(g); g.connect(this.musicGain); g.gain.value = 0.0001; g.gain.linearRampToValueAtTime(0.12, ctx.currentTime+0.02); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.6); o.start(); o.stop(ctx.currentTime+0.7); i++; }, 300);
  };

  MainScene.prototype.playSfx = function(freq, dur){ if(this.customSfx){ const src = this.audioCtx.createBufferSource(); src.buffer = this.customSfx; const g = this.audioCtx.createGain(); g.gain.value=1; src.connect(g); g.connect(this.sfxGain); src.start(); } else { const o=this.audioCtx.createOscillator(); const g=this.audioCtx.createGain(); o.type='square'; o.frequency.value=freq; o.connect(g); g.connect(this.sfxGain); g.gain.value=0.0001; g.gain.linearRampToValueAtTime(0.2, this.audioCtx.currentTime+0.01); g.gain.exponentialRampToValueAtTime(0.0001, this.audioCtx.currentTime+dur); o.start(); o.stop(this.audioCtx.currentTime+dur+0.02); } };

  MainScene.prototype.maybeRollMissions = function(){ // add mission occasionally
    if(Math.random()<0.2) this.missions.push({desc:'Run 30s', goal:30, progress:0, reward:200}); };

  // ---------------- SCENE: UI (overlay) ----------------
  function UIScene(){ Phaser.Scene.call(this,{key:'UIScene'}); }
  UIScene.prototype = Object.create(Phaser.Scene.prototype);
  UIScene.prototype.constructor = UIScene;
  UIScene.prototype.create = function(){
    // expose controls to DOM buttons
    document.getElementById('btnChar').onclick = ()=>this.scene.get('MainScene').switchCharacter();
    document.getElementById('btnTheme').onclick = ()=>this.scene.get('MainScene').switchTheme();
    document.getElementById('btnMute').onclick = ()=>{ const ms = document.getElementById('btnMute'); ms.classList.toggle('muted'); const main = this.scene.get('MainScene'); if(main.audioCtx){ if(this.muted){ main.master.gain.value=1; this.muted=false; ms.innerText='Mute'; } else { main.master.gain.value=0; this.muted=true; ms.innerText='Unmute'; } } };

    // build shop list
    this.buildShop();
    document.getElementById('resetSave').onclick = ()=>{ Save.reset(); location.reload(); };

    // export zip
    document.getElementById('exportZip').onclick = ()=>this.exportZip();

    // show leaderboard
    this.refreshLeaderboard();
  };

  UIScene.prototype.buildShop = function(){ const main = this.scene.get('MainScene'); const defs = main.charDefs; const shop = document.getElementById('shopList'); shop.innerHTML=''; defs.forEach(d=>{ const div = document.createElement('div'); div.className='shop-item'; div.innerHTML = `<div class='center-col'><div>${d.name}</div><div class='small'>Cost: ${d.cost}</div></div>`; const btn = document.createElement('button'); btn.className='button small'; if(main.unlockedChars.has(d.id)){ btn.innerText='Owned'; btn.disabled=true; } else { btn.innerText='Buy'; btn.onclick = ()=>{ if(main.coins >= d.cost){ main.coins -= d.cost; main.unlockedChars.add(d.id); main.save.unlockedChars = Array.from(main.unlockedChars); Save.save(main.save); document.getElementById('coinCount').innerText = main.coins; btn.innerText='Owned'; btn.disabled=true; alert('Purchased '+d.name); } else alert('Not enough coins'); } } div.appendChild(btn); shop.appendChild(div); }); };

  UIScene.prototype.shakeUI = function(){ /* small DOM flash can be added */ };

  UIScene.prototype.refreshLeaderboard = function(){ const lb = document.getElementById('leaderboard'); const saved = Save.load(); const best = saved.bestScores || []; lb.innerHTML = best.slice(0,5).map((s,i)=>`<div class='small'>${i+1}. ${s.name||'Player'} - ${s.score}</div>`).join('') || '<div class="small">No scores yet</div>' };

  UIScene.prototype.exportZip = async function(){ // builds a playable zip: HTML + placeholder assets and the main game file
    const zip = new JSZip();
    // construct a minimal playable HTML which references the single-file (we'll embed everything inline)
    const html = document.documentElement.outerHTML; zip.file('index.html', html);
    zip.generateAsync({type:'blob'}).then(function(content){ saveAs(content, 'endless-runner-playable.zip'); });
  };

  // ---------------- Leaderboard & Save on game over placeholder ----------------
  // For demonstration, expose a global function to submit score
  window.submitScore = function(name, score){ const s = Save.load(); s.bestScores = s.bestScores || []; s.bestScores.push({name:name||'Player', score:Math.floor(score)}); s.bestScores.sort((a,b)=>b.score-a.score); s.bestScores = s.bestScores.slice(0,30); Save.save(s); document.getElementById('leaderboard').innerHTML = s.bestScores.slice(0,5).map((x,i)=>`<div class='small'>${i+1}. ${x.name} - ${x.score}</div>`).join(''); };

  // ---------------- Resize ----------------
  window.addEventListener('resize', ()=>{ game.scale.resize(Math.min(window.innerWidth,1024), Math.min(window.innerHeight,720)); });

  // ---------------- Initialize shop DOM when available ----------------
  document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=>{ const scene = game.scene.getScene('UIScene'); if(scene) scene.buildShop(); },700); });

  // Safety: ensure Save exists
  if(!localStorage.getItem(Save.key)) Save.save(Save.defaultData());
  </script>
</body>
</html>
